# Secondary key-based storage

### Date: 28/04/2024

## Context

There are application specific use cases when we need to store an object instance in MongoDB without being able to rely on the existence of an `id` field. For example, consider the case of an application that receives from an external service an object instance semantically equivalent to a domain object but which type defines a different primary key. If we assume that both object types include a common (set of) field values that uniquely identify a stored document, we could enable secondary key-based domain object storage.

However, the given object instance may include values for a subset of the fields defined at the domain object only. Hence, the given object instance may specify partial contents, sufficient to support the update of a stored document, but insufficient to create a new document.

This ADR explores a couple of approaches to enable secondary key-based object instance storage using the `save` operation.

## Explored Options

### Secondary key inference and composite secondary key declaration

The idea consists of inferring the secondary key from any given object instance to be stored from the definition of the Mongoose schema related to the given instance type. The target secondary key could be identified by a unitary schema property or a combination of schema properties declared as being part of the secondary key (this is not currently possible with Mongoose `Schema`).

As a side note, one may think that the schema `unique` property is ideal for this purpose, but Mongoose schemas may specify multiple `unique` fields or they may only be specified for some domain subtype schemas, just to mention a couple of possible issues. Thus, the `unique` property is not a good resource to infer secondary keys.

The advantage of this approach is simplicity; it requires some modification on the `save` operation implementation details and leveraging Mongoose `Schema` to support combined secondary key specification while the signature and return type of `save` remain the same.

However, the `save` operation must support the update of partial contents of a domain object. This means that the given object can be of type `Object`, making it impossible to infer its domain object type. This, in turn, makes it impossible to determine the schema associated to the type. Hence, it is also impossible to identify those schema fields acting as secondary keys. This approach is only possible to store instances of a given domain object type that specify valid (not necessarily complete) contents.

### Include secondary key as save operation option

In this case, secondary keys can explicitly be defined in a new `secondaryKey` property to be included at the `SaveOptions` type. This approach allows partial content storage under the following conditions:

- the given instance must include a value for each field composing the secondary key
- in the event of single entity matching, the given instance is updated
- in the event of multiple entity matching, the `update` function throws an exception
- in the event of no entity matching, although the given object instance can be of type `Object`, its contents must be valid (not necessarily complete) so that it can be safely inserted

An obvious drawback compared to option #1 is that this approach is more verbose and requires the modification of the `save` operation signature. But the worst drawback is that it introduces some persistence logic leak into application/domain logic, since repository clients are forced to understand persistence semantics i.e., they must know the secondary key definition. This fact invalidates this approach.

## Conclusion

None of the explored approaches is good enough to enable `id`-less partial domain object storage. Therefore, we suggest that anyone willing perform some secondary key-based data storage implements a solution based on the following pseudocode:

```
save(entity, secondaryKeyValues) {
	const document = this.entityModel.findOne(<secondary key query>);
	if (document) { // Mongoose-based entity update
		document.set(entity);
		const updatedDocument = document.save();
		return this.instantiateFrom(updatedDocument);
	}
	else { // Monguito-based entity insertion
		return this.insert(entity);
	}
}
```

Beware that the previous pseudocode does not include the required logic to support some `monguito` features such as polymorphic domain models or audit capabilities for sample simplicity purposes.
